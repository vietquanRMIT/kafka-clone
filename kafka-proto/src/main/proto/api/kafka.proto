syntax = "proto3";

// Define a namespace for all messages in this file.
package api;

// Optional: set code generation options for each language.
option java_package = "com.example.kafka.api";
option java_multiple_files = true;

message Record {
  bytes value = 1;
  int64 offset = 2;
}

// Enums
enum AckLevel {
  NONE = 0;
  ALL = 1;
}

enum ErrorCode {
  OK = 0;
  NOT_LEADER = 1;
  REBALANCE_IN_PROGRESS = 2;
  UNKNOWN_MEMBER_ID = 3;
  TOPIC_ALREADY_EXISTS = 4;
}

// Producer
message ProducerRequest {
  string topic = 1; // where to send the data
  uint32 partition = 2; // which partition it is going to. This should be sent but through the SmartClient instead of manually.
  bytes value = 3; // the value of the message. Should be bytes so it can receive any primal type.
  string key = 7; // optional key for partitioning

  AckLevel ack = 4; // 0: producer does not need to wait for confirmation. 1: producer needs response.
  uint64 producer_id = 5; // unique producer id
  int64 sequence_number = 6; //
}

message ProducerResponse {
  int64 offset = 1;
  ErrorCode error = 2;
  string leader_address = 3;
}

// Consumer
message ConsumerRequest {
  string topic = 1;
  uint32 partition = 2;
  int64 offset = 3; // Offset start
  int64 maxWaitMs = 4; // Max time to wait for new data. If no new data, return what we have.
}

message ConsumerResponse {
  repeated Record records = 1; // Allow returning multiple records in one network call
}

// Consumer group
message CommitOffsetRequest {
  string consumer_group_id = 1;
  string topic = 2;
  uint32 partition = 3;
  int64 offset = 4;
}

message CommitOffsetResponse {
  uint64 offset = 1;
}

// Fetch last committed offset.
message FetchOffsetRequest {
  string consumer_group_id = 1;
  string topic = 2;
  uint32 partition = 3;
}

message FetchOffsetResponse {
  int64 offset = 1;
}

// Create new topic with number of partitions.
message CreateTopicRequest {
  string topic = 1;
  uint32 partitions = 2;
}

message CreateTopicResponse {
  ErrorCode error_code = 1;
}

// --- METADATA DISCOVERY (The Missing Link) ---
message MetadataRequest {
  repeated string topics = 1; // List of topics to fetch. Empty = fetch ALL topics.
}

message MetadataResponse {
  repeated TopicMetadata topics = 1; // The list of topics requested
  repeated Broker brokers = 2;       // List of all available brokers (ID + Host/Port)
}

message TopicMetadata {
  ErrorCode error_code = 1;          // Did we find the topic?
  string name = 2;                   // "demo"
  repeated PartitionMetadata partitions = 3; // List of partitions (0, 1, 2...)
}

message PartitionMetadata {
  ErrorCode error_code = 1;
  uint32 partition_id = 2;    // The partition number (e.g., 0)
  int32 leader_id = 3;        // The Broker ID that is the LEADER (e.g., 101)
  // In real Kafka, we need to  list "replicas" and "isr" here, but for now, Leader is enough.
}

message Broker {
  int32 node_id = 1;   // 101
  string host = 2;     // "localhost"
  int32 port = 3;      // 9092
}

// Service
service Kafka {
  rpc Produce(ProducerRequest) returns (ProducerResponse);
  rpc Consume(ConsumerRequest) returns (ConsumerResponse);
  rpc CommitOffset(CommitOffsetRequest) returns (CommitOffsetResponse);
  rpc FetchOffset(FetchOffsetRequest) returns (FetchOffsetResponse);
  rpc CreateTopic(CreateTopicRequest) returns (CreateTopicResponse);
  rpc GetMetadata(MetadataRequest) returns (MetadataResponse);
}

